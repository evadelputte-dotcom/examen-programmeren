
class Player():
    def __init__(self, name: str, number: int):
        self.name = name
        self.number = number

    def __eq__(self, other):
        if isinstance(other, Player):
            return self.name == other.name
        return False


    def __lt__(self, other):
        if not isinstance(other, Player):
            return NotImplemented
        else:
            return self.number < other.number

    def __str__(self):
        return f"{self.name} ({self.number})"


# Testscenario
player1 = Player("Eden Hazard", 10)
player2 = Player("Moussa Dembele", 19)
player3 = Player("Jan Vertonghen", 5)

players = [player1, player2, player3]

# Print één van de spelers
print(player1)  # Eden Hazard (10)

# Test __eq__ methode
print(player1 == Player("Eden Hazard", 7))  # True, want naam is gelijk
print(player2 == player3)  # False

# Test __lt__ methode via sorted
gesorteerd_team = sorted(team)
for speler in gesorteerd_team:
    print(speler)

Jan Vertonghen (5)
Eden Hazard (10)
Moussa Dembele (19)



class Pass():
    def __init__(self, sender, receiver, nr_of_times:int):
        self.sender = sender
        self.receiver = receiver
        self.nr_of_times = nr_of_times

    def get_weight(self):
        return self.nr_of_times
    def get_start(self):
        return self.sender
    def get_end(self):
        return self.receiver

    def __eq__(self, other):
        if isinstance(other, Pass):
            return self.sender == other.sender and self.receiver == other.receiver

    def __str__(self):
        return f"Pass from {self.sender} to {self.receiver}"

# Testscenario
player1 = Player("Eden Hazard", 10)
player2 = Player("Moussa Dembele", 19)
player3 = Player("Jan Vertonghen", 5)

pass1 = Pass(player1, player2, 3)
pass2 = Pass(player2, player3, 2)
pass3 = Pass(player1, player2, 5)  #zelfde sender en receiver als pass1

passes = [pass1, pass2, pass3]

# Print één Pass object
print(pass1)  # Pass from Eden Hazard to Moussa Dembele

# Test __eq__ methode
print(pass1 == pass3)  # True (zelfde sender en receiver)
print(pass1 == pass2)  # False

# Test get_weight methode
print(pass1.get_weight())  # 3
print(pass3.get_weight())  # 5

class PassGraph():
    def __init__(self, players:list)
        self.players = []
        self.adj ={}

    def add_player(self, player):
        for p in self.players:
            if p.name == player.name:
                return
            else:
                self.players.append(player)
                self.adj[player.name] = []

    def has_player(self, player_or_name):
        if isinstance(player_or_name, Player):
            name = player_or_name.name
        else:
            name = player_or_name
        for p in self.players:
            if p.name == name:
                return True
        return False

    def get_player(self, name):
        for p in self.players:
            if p.name == name:
                return p
        return None

    def add_pass(self, sender, receiver, times=1):
        if times <= 0:
            raise ValueError("Times must be positive")

        # Zorg dat beide spelers al in de graaf zitten
        if sender.name not in self.adj or receiver.name not in self.adj:
            raise ValueError("Both players must be added first")

        # Kijk of de pass al bestaat
        for p in self.adj[sender.name]:
            if p.receiver == receiver:  # direct attribuut vergelijken
                p.nr_of_times += times
                return

        # Anders: nieuwe pass aanmaken
        new_pass = Pass(sender, receiver, times)
        self.adj[sender.name].append(new_pass)

    def get_pass(self, sender_name, receiver_name):
        if sender_name not in self.adj:
            return None
        for p in self.adj[sender_name]:
            if p.receiver.name == receiver_name:  # direct attribuut gebruiken
                return p
        return None

    def neighbors(self, sender_name):
        if sender_name not in self.adj:
            return []
        return self.adj[sender_name]

    def total_weight(self, subset=None):
        if subset is None:
            subset = [p.name for p in self.players]  # alle spelers
        total = 0
        for sender_name in subset:
            if sender_name in self.adj:
                for p in self.adj[sender_name]:
                    if p.receiver.name in subset:
                        total += p.nr_of_times
        return total

    def pass_intensity(self, subset: list[str] | None = None) -> float:
        def pass_intensity(self, subset=None):
            if subset is None:
                subset = [p.name for p in self.players]
            n = len(subset)
            if n < 2:
                return 0.0
            numerator = self.total_weight(subset)
            denominator = n * (n - 1)
            return numerator / denominator

    def top_pairs(self, k=5):
        all_passes = []
        for pass_list in self.adj.values():
            all_passes.extend(pass_list)

        # Handmatig aflopend sorteren op nr_of_times
        for i in range(len(all_passes)):
            for j in range(0, len(all_passes) - i - 1):
                if all_passes[j].nr_of_times < all_passes[j + 1].nr_of_times:
                    all_passes[j], all_passes[j + 1] = all_passes[j + 1], all_passes[j]

        return all_passes[:k]

    def distribution_from(self, sender_name):
        if sender_name not in self.adj:
            return []

        dist = [(p.receiver.name, p.nr_of_times) for p in self.adj[sender_name]]

        # Handmatig aflopend sorteren op het tweede element
        for i in range(len(dist)):
            for j in range(0, len(dist) - i - 1):
                if dist[j][1] < dist[j + 1][1]:  # verwissel als huidige kleiner is dan volgende
                    dist[j], dist[j + 1] = dist[j + 1], dist[j]

        return dist

    def players_list(self):
        return self.players.copy()

    def passes_list(self):
        all_passes = []
        for lst in self.adj.values():
            all_passes.extend(lst)
        return all_passes

    # -------------------
    # Opslaan en inlezen
    # -------------------
    def save_to_txt(self, path_name: str):
        outputfile = open(path_name, "w", encoding="utf-8")
        outputfile.write("[PLAYERS]\n")
        for p in self.players:
            outputfile.write(f"{p.name};{p.number}\n")
        outputfile.write("[PASSES]\n")
        for sender_name in self.adj:
            for p in self.adj[sender_name]:
                outputfile.write(f"{p.sender.name} -> {p.receiver.name} : {p.nr_of_times}\n")
        outputfile.close()

    def load_from_txt(self, path_name: str):
        inputfile = open(path_name, "r", encoding="utf-8")
        lines = inputfile.readlines()
        inputfile.close()

        section = None
        for line in lines:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if line == "[PLAYERS]":
                section = "players"
                continue
            elif line == "[PASSES]":
                section = "passes"
                continue
            elif line.startswith("[") and line.endswith("]"):
                raise ValueError(f"Onbekende sectie: {line}")

            if section == "players":
                if ";" not in line:
                    raise ValueError(f"Ongeldige spelerregel: {line}")
                name, number = map(str.strip, line.split(";"))
                try:
                    number = int(number)
                except:
                    raise ValueError(f"Shirtnummer moet een geheel getal zijn: {line}")
                self.add_player(Player(name, number))
            elif section == "passes":
                if "->" not in line or ":" not in line:
                    raise ValueError(f"Ongeldige passregel: {line}")
                sender_part, rest = line.split("->")
                receiver_part, times_part = rest.split(":")
                sender_name = sender_part.strip()
                receiver_name = receiver_part.strip()
                try:
                    times = int(times_part.strip())
                    if times <= 0:
                        raise ValueError()
                except:
                    raise ValueError(f"Ongeldig aantal passes: {line}")
                sender = self.get_player(sender_name)
                receiver = self.get_player(receiver_name)
                if not sender or not receiver:
                    raise ValueError(f"Pass verwijst naar onbekende speler: {line}")
                self.add_pass(sender, receiver, times)
            else:
                raise ValueError(f"Sectie ontbreekt voor regel: {line}")




