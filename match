class Player:
    def __init__(self, name: str, number: int):
        self.name = name
        self.number = number

    def __eq__(self, other):
        if isinstance(other, Player):
            return self.name == other.name
        return False

    def __lt__(self, other):
        if not isinstance(other, Player):
            return NotImplemented
        return self.number < other.number

    def __str__(self):
        return f"{self.name} ({self.number})"


# ------- TESTSCENARIO -------

# 1. Maak drie spelers
p1 = Player("Eden Hazard", 10)
p2 = Player("Moussa Dembele", 19)
p3 = Player("Jan Vertonghen", 5)

players = [p1, p2, p3]

# 2. Print één object
print(p1)

# 3. Test eq methode
print("p1 == p2?", p1 == p2)   # False
print("p1 == Player('Eden Hazard', 99)?", p1 == Player("Eden Hazard", 99))  # True

# 4. Test lt methode + sorted
sorted_players = sorted(players)

# 5. Print gesorteerde lijst
for p in sorted_players:
    print(p)


class Pass:
    def __init__(self, sender, receiver, nr_of_times: int):
        self.sender = sender
        self.receiver = receiver
        self.nr_of_times = nr_of_times

    def get_weight(self):
        return self.nr_of_times

    def get_start(self):
        return self.sender

    def get_end(self):
        return self.receiver

    def __eq__(self, other):
        if isinstance(other, Pass):
            return self.sender == other.sender and self.receiver == other.receiver
        return False

    def __str__(self):
        return f"Pass from {self.sender.name} to {self.receiver.name}"

      # -------------------------
# TESTSCENARIO
# -------------------------

# 1. Maak 3 Player objecten
p1 = Player("Eden Hazard", 10)
p2 = Player("Moussa Dembele", 19)
p3 = Player("Jan Vertonghen", 5)

# 2. Maak 3 Pass objecten
pass1 = Pass(p1, p2, 7)
pass2 = Pass(p3, p1, 3)
pass3 = Pass(p1, p2, 12)  # zelfde sender & receiver als pass1 → eq moet True geven

# 3. Print één Pass object
print(pass1)

# 4. Test eq methode
print("pass1 == pass2?", pass1 == pass2)  # False
print("pass1 == pass3?", pass1 == pass3)  # True

# 5. Test get_weight
print("Weight of pass1:", pass1.get_weight())  # 7



class PassGraph:
    def __init__(self):
        self.players = []     # lijst Player-objecten
        self.adj = {}         # dictionary: key = player.name, value = list van Pass-objecten

    # -------------------------
    # BASISOPERATIES
    # -------------------------

    def add_player(self, player):
        """Voegt speler toe als de naam nog niet bestaat."""
        # zelf kijken, zonder andere methodes te gebruiken:
        for p in self.players:
            if p.name == player.name:
                return
        self.players.append(player)
        self.adj[player.name] = []

    def has_player(self, player_or_name):
        """Controleer of speler bestaat."""
        if isinstance(player_or_name, Player):
            name = player_or_name.name
        else:
            name = player_or_name

        for p in self.players:
            if p.name == name:
                return True
        return False

    def get_player(self, name):
        """Zoek een speler op naam."""
        for p in self.players:
            if p.name == name:
                return p
        return None

    def add_pass(self, sender, receiver, times=1):
        if times <= 0:
            raise ValueError("times must be > 0")

        # check of beide spelers bestaan
        sender_ok = False
        receiver_ok = False
        for p in self.players:
            if p.name == sender.name:
                sender_ok = True
            if p.name == receiver.name:
                receiver_ok = True

        if not (sender_ok and receiver_ok):
            raise ValueError("Both players must be added first.")

        # bestaat pass al?
        for p in self.adj[sender.name]:
            if p.receiver.name == receiver.name:
                p.nr_of_times += times
                return

        # nieuwe pass
        self.adj[sender.name].append(Pass(sender, receiver, times))

    def get_pass(self, sender_name, receiver_name):
        if sender_name not in self.adj:
            return None
        for p in self.adj[sender_name]:
            if p.receiver.name == receiver_name:
                return p
        return None

    def neighbors(self, sender_name):
        return self.adj.get(sender_name, [])

    # -------------------------
    # ANALYSEMETHODES
    # -------------------------

    def total_weight(self, subset=None):
        if subset is None:
            subset = [p.name for p in self.players]

        total = 0
        for sender in subset:
            if sender not in self.adj:
                continue
            for p in self.adj[sender]:
                if p.receiver.name in subset:
                    total += p.nr_of_times
        return total

    def pass_intensity(self, subset=None):
        if subset is None:
            subset = [p.name for p in self.players]

        n = len(subset)
        if n < 2:
            return 0.0

        numerator = self.total_weight(subset)
        denominator = n * (n - 1)
        return numerator / denominator

    def top_pairs(self, k=5):
        alle = []
        for passes in self.adj.values():
            alle.extend(passes)

        alle.sort(key=lambda p: p.nr_of_times, reverse=True)
        return alle[:k]

    def distribution_from(self, sender_name):
        if sender_name not in self.adj:
            return []

        dist = [(p.receiver.name, p.nr_of_times) for p in self.adj[sender_name]]
        dist.sort(key=lambda x: x[1], reverse=True)
        return dist


    # -------------------------
    # DEEL 4 — EXTRA OPERATIES
    # -------------------------

    def players_list(self):
        return list(self.players)

    def passes(self):
        alle = []
        for lst in self.adj.values():
            alle.extend(lst)
        return alle

    # -------------------------
    # BESTAND INLEZEN
    # -------------------------

    def _load_from_txt(self, path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                lines = f.readlines()
        except FileNotFoundError:
            raise ValueError(f"File not found: {path}")

        section = None

        for raw in lines:
            line = raw.strip()

            if line == "" or line.startswith("#"):
                continue

            if line == "[PLAYERS]":
                section = "PLAYERS"
                continue
            elif line == "[PASSES]":
                section = "PASSES"
                continue
            elif line.startswith("["):
                raise ValueError(f"Unknown section: {line}")

            if section == "PLAYERS":
                if ";" not in line:
                    raise ValueError("Invalid player line")
                name, number = line.split(";")
                name = name.strip()
                try:
                    number = int(number.strip())
                except:
                    raise ValueError("Invalid player number")

                self.add_player(Player(name, number))

            elif section == "PASSES":
                if "->" not in line or ":" not in line:
                    raise ValueError("Invalid pass line")

                left, nr = line.split(":")
                nr = nr.strip()

                try:
                    nr = int(nr)
                except:
                    raise ValueError("Invalid pass weight")

                sender_name, receiver_name = left.split("->")
                sender_name = sender_name.strip()
                receiver_name = receiver_name.strip()

                sender = self.get_player(sender_name)
                receiver = self.get_player(receiver_name)

                if sender is None or receiver is None:
                    raise ValueError("Pass refers to unknown player")

                self.add_pass(sender, receiver, nr)

            else:
                raise ValueError("File structure incomplete: missing section")

    # -------------------------
    # BESTAND OPSLAAN
    # -------------------------

    def save_to_txt(self, path):
        with open(path, "w", encoding="utf-8") as f:
            f.write("[PLAYERS]\n")
            for p in self.players:
                f.write(f"{p.name};{p.number}\n")

            f.write("[PASSES]\n")
            for sender in self.adj:
                for p in self.adj[sender]:
                    f.write(f"{p.sender.name} -> {p.receiver.name} : {p.nr_of_times}\n")
✅ Testscript (zoals gevraagd)
python
Code kopiëren
# TEST DEEL 4

# 1. Graaf opbouwen
g = PassGraph()

p1 = Player("Eden Hazard", 10)
p2 = Player("Moussa Dembele", 19)
p3 = Player("Jan Vertonghen", 5)
p4 = Player("Romelu Lukaku", 9)

g.add_player(p1)
g.add_player(p2)
g.add_player(p3)
g.add_player(p4)

g.add_pass(p1, p2, 3)
g.add_pass(p1, p2, 4)  # moet optellen → totaal 7
g.add_pass(p2, p4, 2)
g.add_pass(p3, p1, 1)
g.add_pass(p4, p3, 5)

# 2. Opslaan
g.save_to_txt("team.txt")

# 3. Inlezen in nieuwe graaf
g2 = PassGraph("team.txt")

# 4. Controleren
print("Ingelezen spelers:", [p.name for p in g2.players])
print("Ingelezen passes:")
for p in g2.passes():
    print(p, "=", p.nr_of_times)




