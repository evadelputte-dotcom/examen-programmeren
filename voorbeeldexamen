# https://dodona.be/nl/courses/5447/series/63929/activities/2121011474

class LinkedNode:
    def __init__(self, task_name:str, duration:int, priority:int):
        self.task_name = task_name
        self.duration = duration
        self.priority = priority
        self.next = None

    def __repr__(self):
        return f'{self.task_name} ({self.duration}, {self.priority})'

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    def add_task(self, task_name:str, duration:int, priority:int):
        NewTask = LinkedNode(task_name, duration, priority)
        if self.head is None:
            self.head = self.tail = NewTask
        else:
            self.tail.next = NewTask
            self.tail = self.tail.next
        self.size += 1

    def remove_task(self, task_name:str):
        current = self.head
        previous = None
        while current:
            if current.task_name == task_name:
                if previous is None:
                    self.head = current.next
                else:
                    previous.next = current.next
                if  current == self.tail:
                    self.tail = previous
                self.size -= 1
                return True
            previous = current
            current = current.next
        return False

    def display(self):
        current = self.head
        previous = None
        while current:
            print(current.task_name)
            previous = current
            current = current.next

    def find_task(self, task_name:str):
        current = self.head
        previous = None
        while current:
            if current.task_name == task_name:
                return (current.task_name, current.duration, current.priority)
            previous = current
            current = current.next
        return None


    def calculate_total_duration(self):
        current = self.head
        previous = None
        total = 0
        while current:
            total += current.duration
            previous = current
            current = current.next
        return total


    def read_task_from_csv(selfself, file_path):
        OutputFile =open(file_path, 'r')
        OutputData = OutputFile.read()
        OutputFile.close()

        # CSV-bestand opsplitsen in regels
        lines = OutputData.splitlines()
        for line in lines:
            # Splits elke regel op komma's
            columns = line.split(',')
            task = columns[0]  # eerste kolom als taak
            self.add_task(task)


    def sorted_insert_by_priority(self, head, node):
        # Als de lijst leeg is, wordt de nieuwe node het begin
        if head is None:
            node.next = None
            return node

        # Als de nieuwe node een lagere duur heeft dan de eerste node,
        # moet hij helemaal vooraan komen
        if node.duration < head.duration:
            node.next = head
            return node

        # Anders zoeken we de juiste plek om in te voegen
        current = head
        while current.next and current.next.duration <= node.duration:
            current = current.next

        # Node invoegen
        node.next = current.next
        current.next = node

        return head

    def sorted_insert_by_priority_duration(self, head, node):
        if head is None:
            node.next = None
            return node

        if (node.priority < head.priority) or \
                (node.priority == head.priority and node.duration < head.duration):
            node.next = head
            return node

        current = head

        while current.next:
            next_node = current.next

            correct_priority = next_node.priority < node.priority
            same_priority = next_node.priority == node.priority
            shorter_duration = next_node.duration <= node.duration

            if not (correct_priority or (same_priority and shorter_duration)):
                break

            current = current.next

        node.next = current.next
        current.next = node

        return head

    def reoder_tasks_by_priority(self):
        new_head = None
        current = self.head
        while current:
            next_node = current.next
            current.next = None
            new_head = self.sorted_insert_by_priority(new_head, current)
            current = next_node
        self.head = new_head

    def reorder_tasks_by_priority_duration(self):
        new_head = None
        current = self.head
        while current:
            next_node = current.next
            current.next = None
            new_head = self.sorted_insert_by_priority_duration(new_head, current)
            current = next_node
        self.head = new_head
